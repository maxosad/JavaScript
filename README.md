# JavaScript
_______________________
A
_______________________
_______________________
B
_______________________
_______________________
C
_______________________
Основное задание
Три компаньона Аркадия – «Danny», «Rusty» и «Linus» – частенько проворачивают тёмные делишки под покровом ночи: пишут на PHP, едят после шести и изредка грабят банки.

Сегодня они подумали, что настало время завязать с тёмными делами. Поэтому решили пойти на последнее ограбление, а после изучить JavaScript и стать законопослушными фронтедерами.

Сейчас уже понедельник, а в четверг в последний банк поставят новую сигнализацию. И у них есть только три дня (понедельник, вторник и среда), чтобы выбрать подходящее время. Во-первых, это должно быть в рабочие часы банка – так легче проникнуть в него.
Во-вторых, все трое должны быть свободны.
И в-третьих, должно быть достаточно времени, чтобы провернуть дело.

Компаньоны быстро составили расписание – когда и кто занят
(заметьте, что грабители находятся в разных часовых поясах):

{
    "Danny": [
        { "from": "ПН 12:00+5", "to": "ПН 17:00+5" },
        { "from": "ВТ 13:00+5", "to": "ВТ 16:00+5" }
    ],
    "Rusty": [
        { "from": "ПН 11:30+5", "to": "ПН 16:30+5" },
        { "from": "ВТ 13:00+5", "to": "ВТ 16:00+5" }
    ],
    "Linus": [
        { "from": "ПН 09:00+3", "to": "ПН 14:00+3" },
        { "from": "ПН 21:00+3", "to": "ВТ 09:30+3" },
        { "from": "СР 09:30+3", "to": "СР 15:00+3" }
    ]
}


И нашли в интернете часы работы банка:

{ "from": "10:00+5", "to": "18:00+5" }
Но выбрать время для ограбления с ходу не получилось, поэтому предлагаем вам написать код с методом (getAppropriateMoment), который на вход принимает расписание (schedule), необходимое для ограбления время (time) в минутах и время работы банка (workingHours), вычисляет подходящее время и на выходе предоставляет объект для работы с ним:

.exists() – отвечает на вопрос найдено ли время вообще
.format(template) – выводит время ограбления в часовом поясе банка и согласно переданному шаблону, который может включать в себя часы HH, минуты MM и день недели DD. Например, «Начинаем в %HH:%MM (%DD)». Если время не найдено, метод возвращает пустую строку.
Дополнительные условия и ограничения:

Все время задачи ограничено неделей c ПН 00:00 до ВС 23:59 в часовом поясе банка
Время ограбления должно попадать в промежуток c ПН 00:00 до СР 23:59 в часовом поясе банка
Банк работает всю неделю
Но работает в рамках только одного дня (не может открыться в один день, а закрыться в другой)
И может открыться в 00:00, а закрыться аж в 23:59
Временная зона задана в часах. Всегда целое число и может быть только положительным – «+5»
Даты приходят всегда правильно, можно опустить обработку неправильных дат и интервалов
Гарантируется одинаковость часового пояса в одном контексте: в рамках расписания одного члена банды, в рамках часов работы банка
Закончить ограбление необходимо тоже до конца рабочего дня банка
Мы выложили пример того как можно работать с вашим кодом под условием задачи, а заготовку для того чтобы реализовать свой код вы можете найти здесь.

Дополнительное задание
Реализовать метод .tryLater(), который находит следующее подходящее время через полчаса от предыдущего. Если найти не получается, то время остается прежнее. Метод возращает true, если получилось найти и false, если нет.

Пример работы этого метода вы может отыскать всё в том же примере внизу.
Будет по-настоящему здорово, если вы его осилите!

0b11

Грабить банки – нехорошо, не повторяйте этого дома!

Пример:
'use strict';

const robbery = require('./robbery');
    
const gangSchedule = {
    Danny: [{ from: 'ПН 12:00+5', to: 'ПН 17:00+5' }, { from: 'ВТ 13:00+5', to: 'ВТ 16:00+5' }],
    Rusty: [{ from: 'ПН 11:30+5', to: 'ПН 16:30+5' }, { from: 'ВТ 13:00+5', to: 'ВТ 16:00+5' }],
    Linus: [
    { from: 'ПН 09:00+3', to: 'ПН 14:00+3' },
    { from: 'ПН 21:00+3', to: 'ВТ 09:30+3' },
    { from: 'СР 09:30+3', to: 'СР 15:00+3' }
    ]
};
    
const bankWorkingHours = {
    from: '10:00+5',
    to: '18:00+5'
};
    
// Время не существует
const longMoment = robbery.getAppropriateMoment(gangSchedule, 121, bankWorkingHours);
    
// Выведется `false` и `""`
console.info(longMoment.exists());
console.info(longMoment.format('Метим на %DD, старт в %HH:%MM!'));
    
// Время существует
const moment = robbery.getAppropriateMoment(gangSchedule, 90, bankWorkingHours);
    
// Выведется `true` и `"Метим на ВТ, старт в 11:30!"`
console.info(moment.exists());
console.info(moment.format('Метим на %DD, старт в %HH:%MM!'));
    
// Дополнительное задание
// Вернет `true`
moment.tryLater();
// `"ВТ 16:00"`
console.info(moment.format('%DD %HH:%MM'));

// Вернет `true`
moment.tryLater();
// `"ВТ 16:30"`
console.info(moment.format('%DD %HH:%MM'));

// Вернет `true`
moment.tryLater();
// `"СР 10:00"`
console.info(moment.format('%DD %HH:%MM'));

// Вернет `false`
moment.tryLater();
// `"СР 10:00"`
console.info(moment.format('%DD %HH:%MM'));
________________________
D
Основное задание
После криминальной интриги с участием друзей Аркадий возвращается в мрачные стены университета — время слушать лекцию и впитывать новые знания.

Вас ждут студенты, готовые внимать каждому слову преподавателя:

const students = {
  Sam: {
    focus: 100,
    wisdom: 50
  },
  Daria: {
    focus: 100,
    wisdom: 60
  }
};
И преподаватель Сергей, который вот-вот начнёт лекцию и покажет первый слайд с бесценной информацией.

lecturer.on('begin', students.Sam, function() {
  // Внимательно слушаем преподователя
  this.focus += 10;
});

lecturer.on('slide', students.Daria, function() {
  // И впитываем мудрость с каждым слайдом
  this.wisdom += 10;
});
Студента можно подписать на событие, производимое преподавателем (например, начало лекции или показ нового слайда) — то есть указать, какая функция должна быть вызвана при наступлении этого события.

Ваша задача — реализовать несколько методов:

подписка на событие — on;
отписка от события — off;
вызов события — emit.
Чтобы задание не казалось совсем простым, вам также нужно реализовать поддержку пространства имён для событий.

// ...

lecturer.on('slide', students.Sam, function() {
  // И впитываем мудрость с каждым слайдом
  this.wisdom += 10;
});

lecturer.on('slide.funny', students.Sam, function() {
  this.wisdom -= 5;
});
Дополнительные условия и ограничения:
События должны возникать в том порядке, в котором на них подписывались;
На одно событие с одинаковыми объектами и обработчиками можно подписаться неограниченное количество раз.
Обработчики вызываются в порядке подписки;
Пространства имён разделены только точкой:
на событие slide.funny произойдут события slide.funny и slide (именно в таком порядке); на событие slidee произойдет slidee, но не slide;
отписка от slide.funny отписывает только от него;
отписка от slide отписывает и от slide, и от slide.funny.
Мы выложили пример того, как можно работать с вашим кодом, под условием задачи. А заготовку для того, чтобы реализовать свой код, вы можете найти здесь.

Дополнительное задание
Необходимо реализовать два дополнительных метода эмиттера. Оба метода работают аналогично on, но обладают некоторыми особенностями:

several — подписывает на первые n событий;
through — подписывает на каждое n-ое событие, начиная с первого.
При отрицательном или нулевом значении through и several начинают работать, как on.

Пример работы этих методов вы можете отыскать всё в том же примере внизу.



Полезные ссылки
Продвинутая работа с функциями
Метод call для функций
Метод apply для функций
Метод bind для функций
Пример:
'use strict';

const { getEmitter } = require('./emitter');

let students = {
  Sam: {
    focus: 100,
    wisdom: 50
  },
  Sally: {
    focus: 100,
    wisdom: 60
  },
  Bill: {
    focus: 90,
    wisdom: 50
  },
  Sharon: {
    focus: 110,
    wisdom: 40
  }
};

let lecturer = getEmitter();

// С началом лекции у всех резко повышаются показатели
lecturer
  .on('begin', students.Sam, function () {
    this.focus += 10;
  })
  .on('begin', students.Sally, function () {
    this.focus += 10;
  })
  .on('begin', students.Bill, function () {
    this.focus += 10;
    this.wisdom += 5;
  })
  .on('begin', students.Sharon, function () {
    this.focus += 20;
  });

// На каждый слайд внимательность падает, но растет мудрость
lecturer
  .on('slide', students.Sam, function () {
    this.wisdom += Math.round(this.focus * 0.1);
    this.focus -= 10;
  })
  .on('slide', students.Sally, function () {
    this.wisdom += Math.round(this.focus * 0.15);
    this.focus -= 5;
  })
  .on('slide', students.Bill, function () {
    this.wisdom += Math.round(this.focus * 0.05);
    this.focus -= 10;
  })
  .on('slide', students.Sharon, function () {
    this.wisdom += Math.round(this.focus * 0.01);
    this.focus -= 5;
  });

// На каждый веселый слайд всё наоборот
lecturer
  .on('slide.funny', students.Sam, function () {
    this.focus += 5;
    this.wisdom -= 10;
  })
  .on('slide.funny', students.Sally, function () {
    this.focus += 5;
    this.wisdom -= 5;
  })
  .on('slide.funny', students.Bill, function () {
    this.focus += 5;
    this.wisdom -= 10;
  })
  .on('slide.funny', students.Sharon, function () {
    this.focus += 10;
    this.wisdom -= 10;
  });

// Начинаем лекцию
lecturer.emit('begin');
// Sam(110,50); Sally(110,60); Bill(100,55); Sharon(130,40)

lecturer
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.funny');
// Sam(75,79); Sally(95,118); Bill(65,63); Sharon(120,34)

lecturer
  .off('slide.funny', students.Sharon)
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.funny');
// Sam(50,90); Sally(85,155); Bill(40,62); Sharon(105,37)

lecturer
  .off('slide', students.Bill)
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.text');

lecturer.emit('end');
// Sam(20,102); Sally(70,191); Bill(40,62); Sharon(90,40)

// Пример работы дополнительного задания
students = {
  Sam: {
    focus: 100,
    wisdom: 50
  },
  Bill: {
    focus: 90,
    wisdom: 50
  }
};

lecturer = getEmitter()
  .several(
    'begin',
    students.Sam,
    function () {
      this.focus += 10;
    },
    1
  )
  .several(
    'begin',
    students.Bill,
    function () {
      this.focus += 10;
      this.wisdom += 5;
    },
    1
  )
  // На Сэма действуют только нечетные слайды
  .through(
    'slide',
    students.Sam,
    function () {
      this.wisdom += Math.round(this.focus * 0.1);
      this.focus -= 10;
    },
    2
  )
  // Концентрации Билла хватит ровно на 4 слайда
  .several(
    'slide',
    students.Bill,
    function () {
      this.wisdom += Math.round(this.focus * 0.05);
      this.focus -= 10;
    },
    4
  )
  .on('slide.funny', students.Sam, function () {
    this.focus += 5;
    this.wisdom -= 10;
  })
  .on('slide.funny', students.Bill, function () {
    this.focus += 5;
    this.wisdom -= 10;
  });

lecturer.emit('begin');
// Sam(110,50); Bill(100,55)

lecturer
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.funny');
// Sam(95,61); Bill(65,63)

lecturer
  .emit('slide.text')
  .emit('slide.text')
  .emit('slide.funny');
// Sam(80,70); Bill(70,53)
________________________
E
Основное задание
Как-то на одной из лекций Аркадий познакомился с девушкой и в скором времени его корабль, под названием «Любовь», наконец-то готов пришвартоваться в бухте, под названием «Семья». Настало время организовать весёлую свадьбу.

Для этого, по мнению Аркадия, должен быть соблюдён ряд условий:

Во-первых, на свадьбе должны быть не только друзья, но и друзья друзей
Во-вторых, слишком незнакомые парни смущают Аркадия и он планирует ограничить уровень неизвестности определённым кругом
В-третьих, чтобы никому не было грустно – он их собирает в пары «парень + девушка»
Аркадий вновь достаёт свою телефонную книгу с записями о друзьях и дополняет её информацией о том, кто и с кем дружит (friends), и кто является его лучшими друзьями (best) таким образом:

const friends = [
    {
        name: 'Sam',
        friends: ['Mat', 'Sharon'],
        gender: 'male',
        best: true
    },
    {
        name: 'Sally',
        friends: ['Brad', 'Emily'],
        gender: 'female',
        best: false
    }
];
И чтобы помочь Аркадию выбрать кого пригласить необходимо подготовить для него удобные фильтры и итераторы для работы с телефонной книгой.

// Создаем фильтры парней и девушек
const maleFilter = new lib.MaleFilter();
const femaleFilter = new lib.FemaleFilter();

// Создаем итераторы
const femaleIterator = new lib.Iterator(friends, femaleFilter);

// Среди парней приглашаем только луших друзей и друзей лучших друзей
const maleIterator = new lib.LimitedIterator(friends, maleFilter, 2);

const invitedFriends = [];

// Собираем пары «парень + девушка»
while (!maleIterator.done() && !femaleIterator.done()) {
    invitedFriends.push([
        maleIterator.next(),
        femaleIterator.next()
    ]);
}

// Если остались девушки, то приглашаем остальных
while (!femaleIterator.done()) {
    invitedFriends.push(femaleIterator.next());
}
Мы выложили пример того как можно работать с вашим кодом под условием задачи, а заготовку для того чтобы реализовать свой код вы можете найти здесь.

Общие условия:

⚠️ Код необходимо написать в интерфейсах, зафиксированных в заготовке. То есть использовать функции-конструкторы и методы работы с прототипами, и не использовать «классы».

Лучшие друзья помечены флагом best
Для каждого друга указан список его друзей
Дружба всегда взаимная
Обход должен происходить, начиная с лучших друзей
Обход всегда идет в алфавитном порядке имен
Друзья не должны обходиться дважды
Первый круг друзей – это лучшие друзья
Второй круг друзей – это друзья лучших друзей
Третий круг и остальные строятся аналогичным образом
Гарантируется, что на входе будут корректные условия
Неориентированный граф друзей
Все перечисленные друзья в свойствах friends будут существовать во входном массиве
Граф друзей может быть несвязным и/или цикличным
Условия для LimitedIterator

Наследник Iterator
Имеет ограничение по кругу maxLevel. Если передан maxLevel равен 1, то итератор обойдет только первый круг друзей, если 2 – первый и второй. И так далее.
Условия для Filter

Создает фильтр, который решает какой друг подходит для итерации
По умолчанию такой фильтр никого не отсеивает
Условия для MaleFilter

Наследник Filter
Позволяет итерироваться по друзьям мужского пола
Условия для FemaleFilter

Наследник Filter
Позволяет итерироваться по друзьям женского пола


Пример использования:
const assert = require('assert');
const lib = require('./lib'); // Ваш файл с кодом задачи

const friends = [
    {
        name: 'Sam',
        friends: ['Mat', 'Sharon'],
        gender: 'male',
        best: true
    },
    {
        name: 'Sally',
        friends: ['Brad', 'Emily'],
        gender: 'female',
        best: true
    },
    {
        name: 'Mat',
        friends: ['Sam', 'Sharon'],
        gender: 'male'
    },
    {
        name: 'Sharon',
        friends: ['Sam', 'Itan', 'Mat'],
        gender: 'female'
    },
    {
        name: 'Brad',
        friends: ['Sally', 'Emily', 'Julia'],
        gender: 'male'
    },
    {
        name: 'Emily',
        friends: ['Sally', 'Brad'],
        gender: 'female'
    },
    {
        name: 'Itan',
        friends: ['Sharon', 'Julia'],
        gender: 'male'
    },
    {
        name: 'Julia',
        friends: ['Brad', 'Itan'],
        gender: 'female'
    }
];

function friend(name) {
    let len = friends.length;

    while (len--) {
        if (friends[len].name === name) {
            return friends[len];
        }
    }
}

const maleFilter = new lib.MaleFilter();
const femaleFilter = new lib.FemaleFilter();
const maleIterator = new lib.LimitedIterator(friends, maleFilter, 2);
const femaleIterator = new lib.Iterator(friends, femaleFilter);

const invitedFriends = [];

while (!maleIterator.done() && !femaleIterator.done()) {
    invitedFriends.push([
        maleIterator.next(),
        femaleIterator.next()
    ]);
}

while (!femaleIterator.done()) {
    invitedFriends.push(femaleIterator.next());
}

assert.deepStrictEqual(invitedFriends, [
    [friend('Sam'), friend('Sally')],
    [friend('Brad'), friend('Emily')],
    [friend('Mat'), friend('Sharon')],
    friend('Julia')
]);
________________________
G
Основное задание
Свадьба Аркадия сыграна, торт съеден, гости проводили молодоженов в их новую семейную жизнь. Что же дальше? А дальше наша молодая пара планирует свое свадебное путешествие. Прагматичный Аркадий посчитал важным заранее продумать свадебное путешествие, чтобы оно было максимально комфортным.

Аркадий едет в свадебное путешествие не только со своей возлюбленной супругой, но и с личным фотографом, поэтому перед нашим программистом-прагматиком стоит не менее прагматичная задача: составить расписание маршрута так, чтобы можно было сделать фотографии с разными погодными условиями в разных городах.

Для того чтобы достичь желаемого, Аркадий решил написать приложение, которое не уступит по своей красоте, простоте и удобству даже Кибертраку Илона Маска. Аркадий слышал, что у Яндекс.Погоды есть удобное API для получения прогноза погоды. Им он и решил воспользоваться в своем приложении.

Аркадию, как известному эстету, хотелось сделать свою библиотеку простой и удобной:

const availableGeoIds = [5, 10, 192, 20, 37];

const sunnyPlan = planTrip(availableGeoIds)
  .sunny(2)
  .cloudy(1)
  .sunny(2)
  .max(3)
  .build();

const cloudyPlan = planTrip(availableGeoIds)
  .cloudy(2)
  .sunny(1)
  .build();
Можно считать, что все города, которые будут передаваться в метод planTrip, расположены между собой на расстоянии, которое Аркадий может преодолеть меньше, чем за половину суток, поэтому про расстояния в рамках данного задания можно забыть. Путешествие начинает свой отсчёт с одного из городов из списка.

Методы-условия
Методы cloudy, sunny, max добавляют условия для будущего путешествия. Они принимают параметр — число дней, в течении которого должно соблюдаться заданное методом условие.
sunny(N) — Солнечная погода N дней. Для API Яндекс.Погоды — это значения condition равные clear и partly-cloud
cloudy(N) — Полная облачность N дней. Для API Яндекс.Погоды — это значения condition равные cloudy и overcast
max(M) — Максимальное количество дней, в котором молодожены хотят быть в одном городе
Для соблюдения условий Аркадий может переместиться в другой город или же остаться в предыдущем городе путешествия. Аркадий с женой очень любят изучать города, по которым путешествуют очень внимательно, поэтому строят маршрут так, чтобы максимальное количество дней побыть в одном городе.

API планировщика
Метод build() инициирует построение маршрута и возвращает Promise с ответом.

Если маршрут по указанным условиям сформировать возможно, то ответом будет массив вида [ { geoid: 1, day: 1 } ], где day – день поездки (начиная с 1).

Если по указанным условиям маршрут построить невозможно, метод build() возвращает Promise, который переходит в состояние rejected с ошибкой и сообщением: Не могу построить маршрут!.

Библиотека для HTTP запросов
В браузер уже встроена глобально доступная функция fetch (она же window.fetch), которая позволяет удобно делать HTTP запросы.

Мы работаем в Node.js окружении и в неё встроены низкоуровневые модули http, https, http2. Они гораздо менее удобные, чем fetch. Предлагаем вам в решении домашнего задания воспользоваться библиотекой node-fetch, которая почти полностью повторяет браузерный аналог. Мы уже установили её для вас.

API Яндекс.Погоды
Для получения прогноза погода на ближайшие семь дней можно обратиться к данному методу API, заменяя лишь параметр geoid на необходимый. За документацией ответа можно обратиться на эту страницу. Для обращения к API вам понадобится получить ключ для тарифа "Тестовый". Положите полученный ключ в файл key.json, чтобы не отправлять ваш секретный ключ вместе с решением. Прогнозом на сутки для города следует считать прогноз в графе day_short.

Дополнительные условия
Запрос к серверу по каждому из городов не должен происходить более одного раза;
Путешествие должно начинаться со дня выполнения запроса на построение маршрута;
Порядок погодных условий нужно иметь в виду;
Посетив город один раз — молодожены уже не захотят туда возвращаться;
Обратите внимание, что на пути у наших молодожёнов не должно быть осадков! То есть погода может быть только clear, partly-cloudy, cloudy и overcast.
Доступные команды
В этот раз задание нужно решать, используя Node.js. Заготовку проекта вы найдете в файле, приложенном к условию задачи внизу (Ссылка "Скачать условие задачи"). Пишите свой код в файле src/weather.js

Перед началом работы выполните команду npm install для установки зависимостей.

Запускаются так: npm run command

Команда	Действие
start	Запуск src/index.js
test	Запуск тестов
Отправка решения
При отправке решения отправляйте только файл weather.js или его содержимое.

Полезные ссылки
________________________
H
Основное задание
На карантине Аркадий сидел в самоизоляции и пересматривал фотографии своего свадебного путешествия. Он захотел выбрать следующее направление, чтобы отправиться туда сразу после открытия границ. Аркадий решил написать свой саджест, в который он будет вводить названия городов или коды аэропортов.

Требования к саджесту:
Саджест выводит предполагаемые города и коды аэропортов данных городов. Найдите самостоятельно базу или API для получения всех аэропортов мира
Саджест работает как по названиям городов, так и по кодам аэропортов
Навигация по пунктам саджеста должна работать не только мышью, но и с клавиатуры
Дозаполнение инпута (т.е. подстановка в инпут текста) происходит по клику/выбору пункта саджеста
Аркадий хочет сосредоточиться на JS, а не на вёрстке. Поэтому его устроит минималистичный дизайн саджеста. Но постарайтесь сделать его удобным в использовании. Например, не забудьте про debounce.
Если вы не совсем понимаете, как должен работать саджест, то можно посмотреть на саджесты travel.yandex.ru или подобных сайтов по поиску авиабилетов. Здесь есть вся требуемая функциональность - навигация мышью и с клавиатуры, вывод кодов аэропортов и так далее.

Сдача работы
В этом задании не будет автотестов. Мы проверим его вручную и оставим комментарии. Для написания кода воспользуйтесь онлайн-редакторами. Рекомендуется использовать jsfiddle. В задачу отправляйте ссылку на кодсниппет. Мы будем проверять последнюю отправленную ссылку.
________________________
